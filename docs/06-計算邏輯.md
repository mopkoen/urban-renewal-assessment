# 計算邏輯 - calculations.ts

## 📍 檔案位置

```
utils/calculations.ts
```

## 🎯 功能說明

`calculations.ts` 是整個系統的核心計算引擎，接收使用者的輸入資料（`InputState`），計算出所有相關的面積、成本、收益和權益分配結果。

## 📝 程式碼結構

### 完整程式碼

```1:137:utils/calculations.ts
import { InputState, CalculationResult } from '../types';

const P = 0.3025; // 1 m2 = 0.3025 ping

export const calculateResults = (inputs: InputState): CalculationResult => {
  // Helper for safe percentage conversion
  const pct = (val: number) => (val || 0) / 100;
  const num = (val: number) => val || 0;

  // Local caps aligned with common TW practices
  const MECH_CAP = 0.10; // 10% of legal FAR
  const STAIR_CAP = 0.15; // 15% of legal FAR
  const BALCONY_CAP = 0.10; // 10% of legal FAR
  const ROOF_CAP_PER_LAYER = 0.10; // 10% of max build area per roof layer

  const area = num(inputs.area);
  const bcRatio = pct(inputs.bcRatio);
  const far = pct(inputs.far);
  const excavate = pct(inputs.excavate);
  const mech = pct(inputs.mech);
  const stair = pct(inputs.stair);
  const balcony = pct(inputs.balcony);
  const roof = pct(inputs.roof);
  const common = pct(inputs.common);
  
  const floors = Math.max(1, Math.floor(num(inputs.floors)));
  const basement = Math.max(0, Math.floor(num(inputs.basement)));
  const roofLayers = Math.max(0, Math.floor(num(inputs.roofLayers)));
  const newUnits = Math.max(0, Math.floor(num(inputs.newUnits)));

  // --- Areas ---
  const maxBuildArea = area * bcRatio;
  const legalFAR = area * far;
  const bonusFAR = legalFAR * 0.5; // Simplified assumption from original code

  const mechArea = Math.min(legalFAR * mech, legalFAR * MECH_CAP);
  const stairArea = Math.min(legalFAR * stair, legalFAR * STAIR_CAP);
  const balconyArea = Math.min(legalFAR * balcony, legalFAR * BALCONY_CAP);
  
  const roofRaw = maxBuildArea * roof * roofLayers;
  const roofArea = Math.min(roofRaw, maxBuildArea * ROOF_CAP_PER_LAYER * roofLayers);

  const excavateArea = area * excavate;
  const basementArea = excavateArea * basement;

  const totalM2 = legalFAR + bonusFAR + mechArea + stairArea + balconyArea + roofArea + basementArea;
  const totalPing = totalM2 * P;

  // --- Sales ---
  const basementPing = basementArea * P;
  const parkAreaPing = basementPing * 0.65;
  const parkSize = num(inputs.parkSize);
  const parkSizeSafe = parkSize > 0 ? parkSize : 8;
  const totalParks = Math.floor(parkAreaPing / parkSizeSafe);
  const aboveGroundPing = Math.max(0, totalPing - basementPing);

  const firstFloorSale = floors > 1 ? aboveGroundPing * 0.65 : aboveGroundPing; 
  const upperFloorSale = floors > 1 ? Math.max(0, aboveGroundPing - firstFloorSale) : 0;
  const totalSalePing = firstFloorSale + upperFloorSale;

  const landEfficiency = (area * P > 0) ? (totalSalePing / (area * P)) : 0;

  // --- Costs ---
  const legalTotalCost = legalFAR * num(inputs.legalCost);
  const rebuildCost = totalPing * num(inputs.buildCost);
  
  const designFee = legalTotalCost * 0.09;
  const fund = legalTotalCost * 0.004;
  const licenseFee = legalTotalCost * 0.001;
  const reviewFee = legalTotalCost * 0.0001;
  const bonusAppFee = legalTotalCost * 0.002;
  const pipeFee = newUnits * 97500;
  const cadastralFee = newUnits * 20000;

  const loanYears = ((6 + 2 * basement + floors + 0.5 * roofLayers + 18) / 12);
  const loanInterest = rebuildCost * 0.0326 * loanYears;
  
  const stampTax = rebuildCost * 0.001;
  const trustFee = rebuildCost * 0.004 * loanYears;
  
  const hrFee = rebuildCost * 0.05;
  const salesFee = rebuildCost * 0.05;
  const riskFee = rebuildCost * 0.05;
  
  const fullMgmtFee = hrFee + salesFee + riskFee;

  // Sum of small fixed fees from inputs
  const rightsFees = num(inputs.planFee) + num(inputs.evalFee) + num(inputs.boundaryFee) + num(inputs.drillFee) + num(inputs.neighborFee);

  const totalCost = rebuildCost + designFee + fund + licenseFee + reviewFee + bonusAppFee + pipeFee + cadastralFee +
                    rightsFees + loanInterest + stampTax + trustFee + fullMgmtFee;
  
  const otherFees = totalCost - rebuildCost - designFee - loanInterest - fullMgmtFee;

  // --- Revenue ---
  const parkRevenue = totalParks * num(inputs.parkPrice);
  const firstRevenue = firstFloorSale * num(inputs.price1F);
  const upperRevenue = upperFloorSale * num(inputs.price2F);
  const totalRevenue = parkRevenue + firstRevenue + upperRevenue;

  const commonBurdenPct = (totalRevenue > 0) ? (totalCost / totalRevenue * 100) : 0;

  // --- Equity ---
  const sellParks = Math.max(0, totalParks - newUnits);
  const sellPct = pct(inputs.sellPercent);
  const sellUpperPing = upperFloorSale * sellPct;
  const cashBack = sellParks * num(inputs.parkPrice) + sellUpperPing * num(inputs.price2F);
  
  const remainUpper = Math.max(0, upperFloorSale - sellUpperPing);
  const returnIndoor = (firstFloorSale + remainUpper) * (1 - common);
  
  const oldPing = Math.max(0.000001, num(inputs.oldPing));
  const pingExchange = returnIndoor / oldPing;
  const returnRatio = (totalSalePing > 0) ? (returnIndoor / totalSalePing) : 0;

  return {
    areas: {
      maxBuildArea, legalFAR, bonusFAR, mechArea, stairArea, balconyArea, roofArea, excavateArea, basementArea, totalPing, totalM2
    },
    sales: {
      parkAreaPing, totalParks, firstFloorSale, upperFloorSale, remainUpper, totalSalePing, landEfficiency
    },
    costs: {
      rebuildCost, designFee, loanInterest, fullMgmtFee, totalCost, commonBurdenPct, otherFees,
      breakdown: {
        fund, licenseFee, reviewFee, bonusAppFee, pipeFee, cadastralFee, rightsFees, stampTax, trustFee
      }
    },
    revenue: {
      parkRevenue, firstRevenue, upperRevenue, totalRevenue
    },
    equity: {
      sellParks, sellUpperPing, cashBack, returnIndoor, pingExchange, returnRatio, loanYears
    }
  };
};
```

## 🔍 詳細說明

### 1. 常數定義

```3:3:utils/calculations.ts
const P = 0.3025; // 1 m2 = 0.3025 ping
```

- **`P`**：平方公尺轉坪的換算係數（1 平方公尺 = 0.3025 坪）

### 2. 輔助函數

```7:8:utils/calculations.ts
  const pct = (val: number) => (val || 0) / 100;
  const num = (val: number) => val || 0;
```

- **`pct`**：將百分比數值（如 45）轉換為小數（0.45）
- **`num`**：確保數值不為 `null` 或 `undefined`，預設為 0

### 3. 容積上限常數

```10:14:utils/calculations.ts
  const MECH_CAP = 0.10; // 10% of legal FAR
  const STAIR_CAP = 0.15; // 15% of legal FAR
  const BALCONY_CAP = 0.10; // 10% of legal FAR
  const ROOF_CAP_PER_LAYER = 0.10; // 10% of max build area per roof layer
```

根據台灣建築法規設定的免計容積上限：
- 機電：法定容積的 10%
- 梯廳：法定容積的 15%
- 陽台：法定容積的 10%
- 屋突：每層最大建築面積的 10%

### 4. 面積計算

#### 基本面積

```31:33:utils/calculations.ts
  const maxBuildArea = area * bcRatio;
  const legalFAR = area * far;
  const bonusFAR = legalFAR * 0.5; // Simplified assumption from original code
```

- **`maxBuildArea`**：最大建築面積 = 基地面積 × 建蔽率
- **`legalFAR`**：法定容積面積 = 基地面積 × 容積率
- **`bonusFAR`**：獎勵容積 = 法定容積 × 50%（簡化假設）

#### 免計容積

```35:41:utils/calculations.ts
  const mechArea = Math.min(legalFAR * mech, legalFAR * MECH_CAP);
  const stairArea = Math.min(legalFAR * stair, legalFAR * STAIR_CAP);
  const balconyArea = Math.min(legalFAR * balcony, legalFAR * BALCONY_CAP);
  
  const roofRaw = maxBuildArea * roof * roofLayers;
  const roofArea = Math.min(roofRaw, maxBuildArea * ROOF_CAP_PER_LAYER * roofLayers);
```

- 各免計容積項目取使用者輸入值與法規上限的較小值
- 屋突面積考慮層數

#### 地下室

```43:44:utils/calculations.ts
  const excavateArea = area * excavate;
  const basementArea = excavateArea * basement;
```

- **`excavateArea`**：開挖面積 = 基地面積 × 開挖率
- **`basementArea`**：地下室面積 = 開挖面積 × 地下層數（假設每層面積相同）

#### 總面積

```46:47:utils/calculations.ts
  const totalM2 = legalFAR + bonusFAR + mechArea + stairArea + balconyArea + roofArea + basementArea;
  const totalPing = totalM2 * P;
```

### 5. 銷售面積計算

```49:59:utils/calculations.ts
  const basementPing = basementArea * P;
  const parkAreaPing = basementPing * 0.65;
  const parkSize = num(inputs.parkSize);
  const parkSizeSafe = parkSize > 0 ? parkSize : 8;
  const totalParks = Math.floor(parkAreaPing / parkSizeSafe);
  const aboveGroundPing = Math.max(0, totalPing - basementPing);

  const firstFloorSale = floors > 1 ? aboveGroundPing * 0.65 : aboveGroundPing; 
  const upperFloorSale = floors > 1 ? Math.max(0, aboveGroundPing - firstFloorSale) : 0;
  const totalSalePing = firstFloorSale + upperFloorSale;
```

- **車位面積**：地下室面積的 65% 用於車位
- **車位數量**：車位總面積 ÷ 單個車位面積（向下取整）
- **一樓銷售**：多層建築時，地上層的 65% 為一樓；單層建築則全部為一樓
- **二樓以上銷售**：多層建築時，地上層的 35%

### 6. 成本計算

#### 基本成本

```63:65:utils/calculations.ts
  const legalTotalCost = legalFAR * num(inputs.legalCost);
  const rebuildCost = totalPing * num(inputs.buildCost);
```

- **`legalTotalCost`**：法定造價總額 = 法定容積面積 × 法定造價單價
- **`rebuildCost`**：重建費用 = 總坪數 × 營建成本單價

#### 設計與規費

```67:74:utils/calculations.ts
  const designFee = legalTotalCost * 0.09;
  const fund = legalTotalCost * 0.004;
  const licenseFee = legalTotalCost * 0.001;
  const reviewFee = legalTotalCost * 0.0001;
  const bonusAppFee = legalTotalCost * 0.002;
  const pipeFee = newUnits * 97500;
  const cadastralFee = newUnits * 20000;
```

- **設計費**：法定造價總額的 9%
- **公基金**：法定造價總額的 0.4%
- **執照費**：法定造價總額的 0.1%
- **審查費**：法定造價總額的 0.01%
- **獎勵申請費**：法定造價總額的 0.2%
- **管線接管費**：每戶 97,500 元
- **地籍費**：每戶 20,000 元

#### 融資利息

```76:77:utils/calculations.ts
  const loanYears = ((6 + 2 * basement + floors + 0.5 * roofLayers + 18) / 12);
  const loanInterest = rebuildCost * 0.0326 * loanYears;
```

- **貸款年數**：根據建築規模計算（6 個月基礎 + 每層 2 個月 + 地上層數 + 屋突層數 × 0.5 + 18 個月）
- **融資利息**：重建費用 × 3.26% × 貸款年數

#### 稅費與管理費

```79:85:utils/calculations.ts
  const stampTax = rebuildCost * 0.001;
  const trustFee = rebuildCost * 0.004 * loanYears;
  
  const hrFee = rebuildCost * 0.05;
  const salesFee = rebuildCost * 0.05;
  const riskFee = rebuildCost * 0.05;
  
  const fullMgmtFee = hrFee + salesFee + riskFee;
```

- **印花稅**：重建費用的 0.1%
- **信託費**：重建費用的 0.4% × 貸款年數
- **管理費**：人事費、銷售費、風險費各 5%，合計 15%

#### 總成本

```87:92:utils/calculations.ts
  const rightsFees = num(inputs.planFee) + num(inputs.evalFee) + num(inputs.boundaryFee) + num(inputs.drillFee) + num(inputs.neighborFee);

  const totalCost = rebuildCost + designFee + fund + licenseFee + reviewFee + bonusAppFee + pipeFee + cadastralFee +
                    rightsFees + loanInterest + stampTax + trustFee + fullMgmtFee;
  
  const otherFees = totalCost - rebuildCost - designFee - loanInterest - fullMgmtFee;
```

### 7. 收益計算

```94:99:utils/calculations.ts
  const parkRevenue = totalParks * num(inputs.parkPrice);
  const firstRevenue = firstFloorSale * num(inputs.price1F);
  const upperRevenue = upperFloorSale * num(inputs.price2F);
  const totalRevenue = parkRevenue + firstRevenue + upperRevenue;

  const commonBurdenPct = (totalRevenue > 0) ? (totalCost / totalRevenue * 100) : 0;
```

- **車位收入**：車位數量 × 車位單價
- **一樓收入**：一樓銷售面積 × 一樓單價
- **二樓以上收入**：二樓以上銷售面積 × 二樓以上單價
- **共同負擔比**：總成本 ÷ 總收入 × 100%

### 8. 權益分配計算

```101:115:utils/calculations.ts
  const sellParks = Math.max(0, totalParks - newUnits);
  const sellPct = pct(inputs.sellPercent);
  const sellUpperPing = upperFloorSale * sellPct;
  const cashBack = sellParks * num(inputs.parkPrice) + sellUpperPing * num(inputs.price2F);
  
  const remainUpper = Math.max(0, upperFloorSale - sellUpperPing);
  const returnIndoor = (firstFloorSale + remainUpper) * (1 - common);
  
  const oldPing = Math.max(0.000001, num(inputs.oldPing));
  const pingExchange = returnIndoor / oldPing;
  const returnRatio = (totalSalePing > 0) ? (returnIndoor / totalSalePing) : 0;
```

- **銷售車位**：總車位數 - 新戶數（需保留給住戶）
- **銷售二樓以上面積**：根據銷售百分比計算
- **變現金額**：銷售車位收入 + 銷售樓層收入
- **分回室內坪數**：(一樓 + 保留二樓以上) × (1 - 公設比)
- **一坪換幾坪**：分回室內坪數 ÷ 更新前原室內坪數（關鍵指標）
- **分回比例**：分回室內坪數 ÷ 總銷售面積

## 🔗 相關檔案

- [類型定義](./05-類型定義.md) - `InputState` 和 `CalculationResult` 介面
- [主應用程式](./04-主應用程式.md) - 呼叫 `calculateResults` 函數
- [結果儀表板](./09-結果儀表板.md) - 顯示計算結果

